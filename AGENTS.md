# Quick guide for support agents

Minimal context for understanding and extending the pseudo-SPA architecture used in this repo.

## Project purpose
- Provide a lightweight framework for static sites that behave like a SPA: internal routing, layout partials, per-page scripts, and an accessible modal service.
- Everything lives in plain JS and CSS, with no bundlers or external frameworks; the final bundle is generated by the Node scripts in `tools/`.

## Main pieces
- `src/bootstrap.js`: entry point. Injects partials (header/footer), marks the active nav link, loads scripts for the current page, and boots the pseudo-SPA router.
- `src/core/layout.js`: helpers to load partials (`fetch` + `innerHTML`) and highlight the active nav link based on the normalized route.
- `src/core/pseudo-spa.js`: intercepts internal links, uses `fetch` to grab the new view, replaces only `<main>` with optional transition classes, updates `history.pushState`, and fires `onAfterNavigate` to rehydrate.
- `src/core/script-loader.js`: reads `window.PageConfig` to load shared and per-`data-page` scripts; optionally executes a global `init` function after navigation.
- `src/core/modal-service.js`: modal service with event delegation (`data-modal-open` / `data-modal-close`), focus management, and a `Modal.getOrCreate(el)` API for programmatic use.

## Page configuration
- The HTML must include `<main data-page="page-id">…</main>` so `PageScriptLoader` loads the correct logic.
- `window.PageConfig` defines layout, scripts, and `init`/`teardown` per page. Minimal example:
  ```js
  window.PageConfig = {
    layout: {
      header: { selector: "#app-header", url: "/partials/header.html" },
      footer: { selector: "#app-footer", url: "/partials/footer.html" },
      navSelector: "#menu a[href]", // optional
    },
    sharedScripts: ["/scripts/shared/common.js"],
    pages: {
      index: {
        scripts: ["/scripts/pages/home.js"], // only lives on this page
        init: "Home.init", // can return a cleanup function
        teardown: "Home.teardown", // optional, called when leaving the view
      },
      about: { scripts: [], init: null },
    },
  };
  ```
  - When changing pages, `PageScriptLoader` removes page-exclusive `<script>` tags, clears their cache, and runs cleanup: first whatever `init` returned (if it did) and then `teardown` if present.
  - Example page module:
    ```js
    window.Home = {
      init() {
        const intervalId = setInterval(tick, 1000);
        document.addEventListener("click", handleClick);
        return () => {
          clearInterval(intervalId);
          document.removeEventListener("click", handleClick);
        };
      },
      teardown() {
        destroyWidgets(); // fallback if init did not return cleanup
      },
    };
    ```
  - “Cleanup” means the function that undoes what `init` set up (listeners, timers, instances) when you leave the page. It can come from two places:
    1. The function returned by `init` (if it returns one).  
    2. The `teardown` function declared in `PageConfig.pages[...].teardown` (global reference).  
    `PageScriptLoader` runs them in that order before loading the next view.

## Bootstrap flow
1) On page load, `bootstrap.js` injects header/footer according to `PageConfig.layout`.
2) It marks the active nav link that best matches the normalized URL.
3) It calls `PageScriptLoader.loadForPage(pageId)` for the current view.
4) It initializes `PseudoSPA`, which on navigation re-marks nav and reloads scripts/`init` for the new view.

## Artifact builds
- JS: `node tools/build-arch-bundle.js` concatenates the pieces into `dist/bundle.js` (includes the ASCII banner).
- CSS: `node tools/build-arch-styles.js` concatenates `.css` files in `src/styles/` and generates `dist/arch-core.css`. Includes modal styles (`src/styles/modal.css`).
- Consumption: in the final HTML, include `<link rel="stylesheet" href="/dist/arch-core.css" />` and `<script src="/dist/bundle.js"></script>`.

## Modal service
- Recommended declarative usage:
  ```html
  <button data-modal-open="#mi-modal">Open modal</button>
  <section id="mi-modal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal__backdrop" data-modal-close></div>
    <div class="modal__dialog" role="document">
      <button class="modal__close" aria-label="Close" data-modal-close>×</button>
      <!-- content -->
    </div>
  </section>
  ```
- Programmatic: `const modal = Modal.getOrCreate(document.querySelector("#mi-modal")); modal.open();`
- Listeners use delegation on `document`, so they keep working after `<main>` swaps without rehydration.

## Collaboration tips
- Keep HTML structured so `<main>` contains replaceable content and preserves the `data-page` attribute.
- If you add new views, remember to register their scripts/`init` in `PageConfig.pages`.
- Transition classes are controlled in `PageConfig.transition` (see defaults in `pseudo-spa.js`).
- Avoid mutating globals outside `window.PageConfig` and the exposed APIs (`Layout`, `PseudoSPA`, `PageScriptLoader`, `Modal`) to preserve compatibility with consuming projects.
